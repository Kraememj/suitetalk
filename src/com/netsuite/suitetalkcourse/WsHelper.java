package com.netsuite.suitetalkcourse;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Random;
import java.util.Base64;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.HttpsURLConnection;


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.netsuite.jdbcx.openaccess.OpenAccessDataSource;
import com.netsuite.webservices.platform.core_2017_2.Passport;
import com.netsuite.webservices.platform.core_2017_2.Record;
import com.netsuite.webservices.platform.core_2017_2.TokenPassport;
import com.netsuite.webservices.platform.core_2017_2.TokenPassportSignature;
import com.netsuite.webservices.platform.core_2017_2.types.SignatureAlgorithm;

public class WsHelper {
   
   /**
    * This generates the TokenPassport object used by the integration client for
    * authenticating an account without using username and password combination
    * 
    * @param accountId      ID of the NetSuite account you intend to connect to.
    * @param consumerKey    Generated by creating an integration record.
    * @param consumerSecret Generated by creating an integration record.
    * @param tokenId        Generated when a token is created.
    * @param tokenSecret    Generated when a token is created.
    * @return Generated TokenPassport object
    * @throws UnsupportedEncodingException
    */
   public static TokenPassport generateTokenPassport(String accountId, String consumerKey, String consumerSecret, String tokenId, String tokenSecret) throws UnsupportedEncodingException{
      String nonce   = generateNonce();
      long timestamp = generateTimestamp();
     
      TokenPassportSignature signature = getPassportSignature(accountId, consumerKey, consumerSecret, tokenId, tokenSecret, nonce, timestamp);
      TokenPassport tokenPassport = new TokenPassport(accountId, consumerKey, tokenId, nonce, timestamp, signature);

      return tokenPassport;
   }
   
   
   /**
    * Generate the passport signature needed for creating the TokenPassport Object
    * 
    * @param accountId      ID of the NetSuite account you intend to connect to.
    * @param consumerKey    Generated by creating an integration record.
    * @param consumerSecret Generated by creating an integration record.
    * @param tokenId        Generated when a token is created.
    * @param tokenSecret    Generated when a token is created.
    * @param nonce          Random characters used for hashing the signature.
    * @param timestamp      Trusted timestamp for the signature generation
    * @return Generated passport signature object
    */
   private static TokenPassportSignature getPassportSignature(String account, String consumerKey, String consumerSecret, String tokenId, String tokenSecret, String nonce, Long timestamp) {
      String result    = "";
      String algorithm = "HmacSHA1";
      
      try {
         String baseString = String.format("%s&%s&%s&%s&%s", account, consumerKey, tokenId, nonce, timestamp); 
         String keyString  = String.format("%s&%s", consumerSecret, tokenSecret);
      
         byte[] keyBytes = keyString.getBytes();
         SecretKeySpec signingKey = new SecretKeySpec(keyBytes, algorithm);

         Mac mac = Mac.getInstance(algorithm);
         mac.init(signingKey);

         byte[] rawHmac = mac.doFinal(baseString.getBytes());
         byte[] decodedBytes = Base64.getDecoder().decode(rawHmac);

         result = new String(decodedBytes);
      
      } catch (NoSuchAlgorithmException e) {
         System.out.println("\nInvalid Algorithm Specified. " + e.getMessage());
         System.out.println("   [Fault Code]: " + e.getStackTrace());
         
      } catch (InvalidKeyException e) {
         System.out.println("\nInvalid Key. " + e.getMessage());
         System.out.println("   [Fault Code]: " + e.getStackTrace());
      }
      
      TokenPassportSignature passportSignature = new TokenPassportSignature();
      passportSignature.setAlgorithm(SignatureAlgorithm._HMAC_SHA1);
      passportSignature.set_value(result);
      
      return passportSignature;
   }
   
   /**
    * Generates a single use value for encryption. This value is needed for creating tokens.
    * 
    * @return Nonce String
    */
   private static String generateNonce() {
      final String RANDOM_CHARACTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      final Random RANDOM = new Random();   
      
      StringBuilder sb = new StringBuilder(20);
      for (int i = 0; i < 20; i++) {
         sb.append(RANDOM_CHARACTERS.charAt(RANDOM.nextInt(RANDOM_CHARACTERS.length())));
      }
      
      return sb.toString();
   }
   
   /**
    * Generates the timestamp. This value is needed for creating tokens.
    * 
    * @return Timestamp used by the token signature.
    */
   private static long generateTimestamp() {
      return System.currentTimeMillis() / 1000L;
   }
   
   
   /**
    * Generate the header string necessary for authenticating RESTlet calls.
    * 
    * @param passport The Passport object here is used to transport the necessary information to the method.
    * @return The NLAuth string that will be set in the header of the RESTlet call.
    */
   public static String generateNLAuthHeader(Passport passport) {
      String header = String.format("NLAuth nlauth_account=%s, nlauth_email=%s, nlauth_signature=%s, nlauth_role=%s",
          passport.getAccount(), passport.getEmail(), passport.getPassword(), passport.getRole().getInternalId());

      return header;
   }
   
   
   /**
    * This is a convenience method that calls a RESTlet service via GET.
    * 
    * @param restletUrlString External URL of the RESTlet service that will be called
    * @param nlAuthHeader NLAuth Header String. This will be used to authenticate the method call
    * @param parameters List of key/value pairs that will be passed to the RESTlet as parameters.
    * @return String response from the RESTlet
    */
   public static String getByRestlet(String restletUrlString, String nlAuthHeader, HashMap<String, String> parameters) {
      String response = "";

      // Add the parameters to the request
      for (Entry <String, String> e : parameters.entrySet()) {
         restletUrlString = String.format("%s&%s=%s", restletUrlString, e.getKey(), e.getValue()); 
      }
      
      try {
         // Create the connection
         HttpsURLConnection urlConn = createUrlConnection("GET", restletUrlString, nlAuthHeader);
         
         // Rest the RESTlet response
         BufferedReader br = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
         StringBuilder  sb = new StringBuilder();
         String line;
         while ((line = br.readLine()) != null) { sb.append(line + "\n"); }
         br.close();
         
         response = sb.toString();
         
      } catch (IOException e) {
         System.out.println("IO Exception [Message]: " + e.getMessage());
         e.printStackTrace();
      }
      
      return response;
   }


   /**
    * This is a convenience method that calls a RESTlet service via POST.
    * 
    * @param restletUrlString External URL of the RESTlet service that will be called.
    * @param nlAuthHeader NLAuth Header String. This will be used to authenticate the method call.
    * @param record Record that you want to add to NetSuite.
    * @return String response from the RESTlet
    */
   public static String postByRestlet(String restletUrlString, String nlAuthHeader, Record record) {
      String responseString = "";
      
      try {
         // Conver the record into JSON.
         ObjectMapper mapper = new ObjectMapper();
         String json = mapper.writeValueAsString(record);
         // Add the record type to the JSON string
         String finalJson = json.substring(0, json.length()-1) + String.format(", \"recType\" : \"%s\"}", record.getClass().getSimpleName());
         
         // Create the connection 
         HttpsURLConnection urlConn = createUrlConnection("POST", restletUrlString, nlAuthHeader);
         
         // Send request
         DataOutputStream wr = new DataOutputStream(urlConn.getOutputStream());
         wr.writeBytes(finalJson);
         wr.flush();
         wr.close();

         // Get Response
         InputStream    is = urlConn.getInputStream();
         BufferedReader rd = new BufferedReader(new InputStreamReader(is));
         String line;
         StringBuffer response = new StringBuffer();
         while ((line = rd.readLine()) != null) {
          response.append(line);
          response.append('\r');
         }
         rd.close();
         
         responseString = response.toString();
         
      } catch (JsonProcessingException e) {
         System.out.println("Problem with processing JSON string [Message]: " + e.getMessage());
         e.printStackTrace();
         
      } catch (IOException e) {
         System.out.println("IO Exception [Message]: " + e.getMessage());
         e.printStackTrace();
      }
      
      return responseString;
   }
   
   
   /**
    * Creates the HttpsURLConnection object that will be used for connecting to the RESTlet.
    * 
    * @param requestMethod "GET" or "POST". This determines the kind of operation used for the operation.
    * @param restletUrlString External URL of the RESTlet service that will be called
    * @param nlAuthHeader NLAuth header that is required for authentication
    * @return Created HttpsURLConnection. This will be used when the RESTlet is called
    */
   private static HttpsURLConnection createUrlConnection(String requestMethod, String restletUrlString, String nlAuthHeader) {
      HttpsURLConnection urlConn = null;

      try {
         URL restletUrl = new URL(restletUrlString);
         urlConn = (HttpsURLConnection) restletUrl.openConnection();
         urlConn.setRequestMethod(requestMethod);
         urlConn.setRequestProperty( "Content-type", "application/json" );
         urlConn.setRequestProperty( "Authorization",  nlAuthHeader);
         urlConn.setAllowUserInteraction(false); 
         urlConn.setDoOutput(true);     
         
      } catch (MalformedURLException e) {
         System.out.println("Malformed URL [Message]: " + e.getMessage());
         e.printStackTrace();
         
      } catch (IOException e) {
         System.out.println("IO Exception [Message]: " + e.getMessage());
         e.printStackTrace();
      }
      
      return urlConn;
   }
   
   
   /**
    * Creates the Connection object necessary to connect to the JDBC server
    * 
    * @param passport The Passport object here is used to transport the necessary information to the method.
    * @return Configured Connection object
    */
   public static Connection createConnection(Passport passport) {
      // Setting the Properties of the connection
      String mail		= passport.getEmail();
      String pass		= passport.getPassword();
      String accountId	= passport.getAccount();
      int roleId		= Integer.valueOf(passport.getRole().getInternalId());

      Connection connection = null;
      try {
         OpenAccessDataSource sds = new OpenAccessDataSource();
         sds.setServerDataSource("NetSuite.com");
         sds.setServerName("odbcserver.na2.netsuite.com");
         sds.setPortNumber(1708);
         sds.setCustomProperties(String.format("(AccountID=%s;RoleID=%d)", accountId, roleId));
         sds.setEncrypted(1);

         connection = sds.getConnection(mail, pass);

      } catch (SQLException e) {
         System.out.println("\n\n[SQL Exception]: " + e.getMessage());
         e.printStackTrace();
      }

      return connection;
   }

   
   /**
    * Closes all resources opened during the database call.
    * 
    * @param rs Resultset
    * @param statement Statement
    * @param conn Connection
    */
   public static void cleanResources(ResultSet rs, Statement statement, Connection conn) {
      if (rs != null) {
         try {
            rs.close();
         } catch (SQLException e) {
            System.out.println("\n\n[SQL Exception]: " + e.getMessage());
            e.printStackTrace();
         }
      }
      if (statement != null) {
         try {
            statement.close();
         } catch (SQLException e) {
            System.out.println("\n\n[SQL Exception]: " + e.getMessage());
            e.printStackTrace();
         }
      }
      if (conn != null) {
         try {
            conn.close();
         } catch (SQLException e) {
            System.out.println("\n\n[SQL Exception]: " + e.getMessage());
            e.printStackTrace();
         }
      }
   }
}
